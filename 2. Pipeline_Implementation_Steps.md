# CI/CD Pipeline Implementation Guide
## Step-by-Step Procedure

### Phase 1: Repository Setup and Jenkins Configuration

#### Step 1: Git Repository Structure
```bash
my-application/
├── src/                    # Application source code
├── Dockerfile             # Container definition
├── Jenkinsfile           # Pipeline definition
├── k8s/                  # Kubernetes manifests
│   ├── deployment.yaml
│   ├── service.yaml
│   └── ingress.yaml
├── terraform/            # Infrastructure code
│   ├── main.tf
│   ├── variables.tf
│   └── outputs.tf
├── ansible/              # Configuration management
│   ├── playbook.yml
│   └── roles/
└── monitoring/           # Monitoring configs
    ├── prometheus.yml
    └── grafana-dashboard.json
```

#### Step 2: Jenkins Pipeline Setup (Jenkinsfile)
```groovy
pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-west-2'
        ECR_REPOSITORY = '123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app'
        CLUSTER_NAME = 'production-eks-cluster'
    }
    
    stages {
        stage('Code Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/company/my-application.git'
            }
        }
        
        stage('Build & Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'npm test'
                        publishTestResults testResultsPattern: 'test-results.xml'
                    }
                }
                stage('Code Quality') {
                    steps {
                        sh 'sonar-scanner'
                    }
                }
            }
        }
        
        stage('Docker Build') {
            steps {
                script {
                    docker.build("${ECR_REPOSITORY}:${BUILD_NUMBER}")
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                sh 'docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy ${ECR_REPOSITORY}:${BUILD_NUMBER}'
            }
        }
        
        stage('Push to ECR') {
            steps {
                script {
                    docker.withRegistry("https://${ECR_REPOSITORY}", 'ecr:us-west-2:aws-credentials') {
                        docker.image("${ECR_REPOSITORY}:${BUILD_NUMBER}").push()
                        docker.image("${ECR_REPOSITORY}:${BUILD_NUMBER}").push('latest')
                    }
                }
            }
        }
        
        stage('Infrastructure Deployment') {
            steps {
                dir('terraform') {
                    sh '''
                        terraform init
                        terraform plan -var="image_tag=${BUILD_NUMBER}"
                        terraform apply -auto-approve -var="image_tag=${BUILD_NUMBER}"
                    '''
                }
            }
        }
        
        stage('Configure Infrastructure') {
            steps {
                dir('ansible') {
                    sh '''
                        ansible-playbook -i inventory/production playbook.yml \
                        --extra-vars "image_tag=${BUILD_NUMBER}"
                    '''
                }
            }
        }
        
        stage('Deploy to EKS') {
            steps {
                sh '''
                    aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                    kubectl set image deployment/my-app my-app=${ECR_REPOSITORY}:${BUILD_NUMBER}
                    kubectl rollout status deployment/my-app
                '''
            }
        }
        
        stage('Health Check') {
            steps {
                sh '''
                    sleep 30
                    kubectl get pods -l app=my-app
                    curl -f http://my-app-service/health || exit 1
                '''
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            slackSend(color: 'good', message: "Deployment successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
        failure {
            slackSend(color: 'danger', message: "Deployment failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
    }
}
```

### Phase 2: Terraform Infrastructure Code

#### Step 3: Main Terraform Configuration (main.tf)
```hcl
# Provider Configuration
provider "aws" {
  region = var.aws_region
}

# VPC and Networking
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  
  name = "production-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["${var.aws_region}a", "${var.aws_region}b", "${var.aws_region}c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = false
  
  tags = {
    Environment = "production"
    Project     = "cicd-pipeline"
  }
}

# EKS Cluster
module "eks" {
  source = "terraform-aws-modules/eks/aws"
  
  cluster_name    = "production-eks-cluster"
  cluster_version = "1.27"
  
  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets
  
  # EKS Managed Node Groups
  eks_managed_node_groups = {
    production_nodes = {
      min_size     = 2
      max_size     = 10
      desired_size = 3
      
      instance_types = ["t3.medium"]
      capacity_type  = "ON_DEMAND"
      
      labels = {
        Environment = "production"
        NodeGroup   = "production"
      }
    }
  }
  
  tags = {
    Environment = "production"
    Project     = "cicd-pipeline"
  }
}

# ECR Repository
resource "aws_ecr_repository" "app_repository" {
  name = "my-application"
  
  image_scanning_configuration {
    scan_on_push = true
  }
  
  tags = {
    Environment = "production"
    Project     = "cicd-pipeline"
  }
}

# Application Load Balancer
resource "aws_lb" "application_lb" {
  name               = "production-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb_sg.id]
  subnets           = module.vpc.public_subnets
  
  tags = {
    Environment = "production"
    Project     = "cicd-pipeline"
  }
}

# Security Groups
resource "aws_security_group" "alb_sg" {
  name_prefix = "production-alb-sg"
  vpc_id      = module.vpc.vpc_id
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Environment = "production"
    Project     = "cicd-pipeline"
  }
}
```

### Phase 3: Ansible Configuration Management

#### Step 4: Ansible Playbook (playbook.yml)
```yaml
---
- name: Configure EKS Cluster and Deploy Monitoring
  hosts: localhost
  connection: local
  vars:
    cluster_name: "production-eks-cluster"
    aws_region: "us-west-2"
    namespace: "monitoring"
    
  tasks:
    - name: Update kubeconfig
      shell: |
        aws eks update-kubeconfig --region {{ aws_region }} --name {{ cluster_name }}
      
    - name: Create monitoring namespace
      kubernetes.core.k8s:
        name: "{{ namespace }}"
        api_version: v1
        kind: Namespace
        state: present
        
    - name: Deploy Prometheus
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: prometheus
            namespace: "{{ namespace }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: prometheus
            template:
              metadata:
                labels:
                  app: prometheus
              spec:
                containers:
                - name: prometheus
                  image: prom/prometheus:latest
                  ports:
                  - containerPort: 9090
                  volumeMounts:
                  - name: prometheus-config
                    mountPath: /etc/prometheus
                volumes:
                - name: prometheus-config
                  configMap:
                    name: prometheus-config
                    
    - name: Deploy Grafana
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: grafana
            namespace: "{{ namespace }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: grafana
            template:
              metadata:
                labels:
                  app: grafana
              spec:
                containers:
                - name: grafana
                  image: grafana/grafana:latest
                  ports:
                  - containerPort: 3000
                  env:
                  - name: GF_SECURITY_ADMIN_PASSWORD
                    value: "admin123"
                    
    - name: Create Prometheus Service
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: prometheus-service
            namespace: "{{ namespace }}"
          spec:
            selector:
              app: prometheus
            ports:
            - port: 9090
              targetPort: 9090
            type: LoadBalancer
            
    - name: Create Grafana Service
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: grafana-service
            namespace: "{{ namespace }}"
          spec:
            selector:
              app: grafana
            ports:
            - port: 3000
              targetPort: 3000
            type: LoadBalancer
```

### Phase 4: Kubernetes Application Deployment

#### Step 5: Application Deployment Manifest (k8s/deployment.yaml)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app:latest
        ports:
        - containerPort: 8080
        env:
        - name: NODE_ENV
          value: "production"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  annotations:
    kubernetes.io/ingress.class: "alb"
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-app-service
            port:
              number: 80
```

### Phase 5: Monitoring Configuration

#### Step 6: Prometheus Configuration (monitoring/prometheus.yml)
```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
    - role: pod
    relabel_configs:
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
      action: keep
      regex: true
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
      action: replace
      target_label: __metrics_path__
      regex: (.+)
    - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
      action: replace
      regex: ([^:]+)(?::\d+)?;(\d+)
      replacement: $1:$2
      target_label: __address__

  - job_name: 'kubernetes-nodes'
    kubernetes_sd_configs:
    - role: node
    relabel_configs:
    - action: labelmap
      regex: __meta_kubernetes_node_label_(.+)

alerting:
  alertmanagers:
  - static_configs:
    - targets:
      - alertmanager:9093
```

### Phase 6: Implementation Timeline

#### Week 1: Foundation Setup
- Day 1-2: Git repository structure and branching strategy
- Day 3-4: Jenkins installation and basic pipeline configuration
- Day 5: Docker containerization and ECR setup

#### Week 2: Infrastructure Automation
- Day 1-3: Terraform code development and testing
- Day 4-5: Ansible playbooks creation and validation

#### Week 3: Kubernetes & Monitoring
- Day 1-2: EKS cluster deployment and configuration
- Day 3-4: Application deployment to EKS
- Day 5: Prometheus and Grafana setup

#### Week 4: Testing & Optimization
- Day 1-2: End-to-end pipeline testing
- Day 3-4: Performance tuning and security hardening
- Day 5: Documentation and knowledge transfer

### Phase 7: Troubleshooting Common Issues

#### Jenkins Pipeline Issues
```bash
# Check Jenkins logs
kubectl logs -f jenkins-pod-name

# Validate Docker build
docker build -t test-image .
docker run --rm test-image

# Debug Terraform
terraform plan -detailed-exitcode
terraform apply -auto-approve -lock=false
```

#### EKS Deployment Issues
```bash
# Check cluster status
aws eks describe-cluster --name production-eks-cluster

# Validate kubectl configuration
kubectl config current-context
kubectl get nodes

# Debug pod issues
kubectl describe pod pod-name
kubectl logs pod-name
```

#### Monitoring Issues
```bash
# Check Prometheus targets
curl http://prometheus-service:9090/api/v1/targets

# Validate Grafana connectivity
kubectl port-forward svc/grafana-service 3000:3000

# Check monitoring namespace
kubectl get all -n monitoring
```